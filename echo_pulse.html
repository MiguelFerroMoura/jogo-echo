<!-- Desenvolvido por Miguel Ferro 20/02/2025 -->

<!-- Modificação feita dia 19/03/2025 modificações implementadas no código: -->
<!-- - Adicionada energia limitada para pulsos com barra de recarga -->
<!-- - Inserido cooldown (tempo de espera) entre pulsos -->
<!-- - HUD atualizado para mostrar tempo, pulsos usados e nível -->
<!-- - Pulso contínuo testado, mas removido por deixar o jogo fácil demais -->

<!-- Modificação feita dia 26/04/2025 modificações implementadas no código: -->
<!-- - Labirinto agora é gerado de forma aleatória em cada fase -->
<!-- - Portal reposicionado automaticamente a cada nível -->
<!-- - Power-ups de visão prolongada testados, mas removidos por desequilibrar -->

<!-- Modificação feita dia 6/06/2025 modificações implementadas no código: -->
<!-- - Criada tela de vitória com estatísticas (tempo e pulsos usados) -->
<!-- - Melhor desempenho salvo em localStorage -->
<!-- - Minimapa testado (mostrar parte do mapa permanentemente), mas removido -->

<!-- Modificação feita dia 30/06/2025 modificações implementadas no código: -->
<!-- - Adicionados sentinelas estáticos, visíveis apenas com pulso -->
<!-- - Colisão com sentinelas faz o jogador perder -->
<!-- - Patrulha automática dos sentinelas testada, mas removida por falhas -->

<!-- Modificação feita dia 29/07/2025 modificações implementadas no código: -->
<!-- - Pulso de som agora é emitido da posição do jogador ao invés do local do clique -->
<!-- - Implementados sentinelas que ficam parados mas são atraídos pelo som -->
<!-- - Sentinelas com visão testados, mas removidos por tornar o jogo injusto -->

<!-- Modificação feita dia 27/08/2025 modificações implementadas no código: -->
<!-- - Sentinelas não conseguem ver o jogador, apenas são atraídos pelo som -->
<!-- - Colisão com sentinelas reinicia o nível -->
<!-- - Sistema de alerta crescente testado, mas removido por deixar o jogo impossível -->

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>EchoPulse — Jogo por Ecolocalização (Modificado)</title>
  <style>
    :root {
      --bg: #0b0e12;
      --fg: #e8f1ff;
      --accent: #7ae0ff;
      --accent2: #8cffb5;
      --muted: #a4b3c4;
      --danger: #ff6b6b;
      --card: #11161d;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu;
      color: var(--fg); background: radial-gradient(1200px 800px at 70% -10%, #18202b 0%, var(--bg) 60%);
      display: grid; place-items: center;
    }
    .shell {
      width: min(1100px, 96vw); height: min(720px, 92vh);
      background: linear-gradient(180deg, #0f141b 0%, #0a0e13 100%);
      border: 1px solid #1e2631; border-radius: 18px; overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 80px rgba(122,224,255,.04);
      display: grid; grid-template-columns: 320px 1fr; gap: 0;
    }
    @media (max-width: 900px) {
      .shell { grid-template-columns: 1fr; grid-template-rows: auto 1fr; height: 100vh; width: 100vw; border-radius: 0; }
    }
    .panel {
      background: linear-gradient(180deg, #0b1016 0%, #0a0f15 100%);
      padding: 18px 18px 14px; border-right: 1px solid #14202c; position: relative;
    }
    @media (max-width: 900px) { .panel { border-right: none; border-bottom: 1px solid #14202c; } }

    h1 { margin: 0 0 6px; font-size: 28px; letter-spacing: .4px; }
    h1 span { color: var(--accent); }
    .sub { color: var(--muted); font-size: 13px; margin-bottom: 14px; }

    .controls, .stats, .toggles { background: var(--card); border: 1px solid #17202a; border-radius: 14px; padding: 12px; margin-bottom: 12px; }
    .controls kbd { background: #0e151d; border: 1px solid #1b2836; border-bottom-color: #0a1118; padding: 3px 6px; border-radius: 6px; font-size: 12px; color: #d5e6ff; }
    .controls p { margin: 8px 0; }

    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; font-size: 14px; }
    .row strong { font-variant-numeric: tabular-nums; }

    button.primary {
      width: 100%; padding: 12px 14px; border-radius: 12px; border: 1px solid #1a2736;
      background: linear-gradient(180deg, #142032 0%, #0f1a28 100%);
      color: var(--fg); font-weight: 700; letter-spacing: .4px; cursor: pointer;
      box-shadow: 0 6px 24px rgba(122,224,255,.12), inset 0 1px 0 rgba(255,255,255,.05);
      transition: transform .06s ease, box-shadow .2s ease, background .2s ease;
    }
    button.primary:hover { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(122,224,255,.18); }

    .badge { display: inline-block; padding: 4px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #1a2736; background: #0f1a28; color: var(--accent2); font-weight: 700; }

    canvas { width: 100%; height: 100%; display: block; background: radial-gradient(900px 600px at 50% 0%, #0a0e14 0%, #05070a 65%);
      filter: drop-shadow(0 0 24px rgba(122,224,255,.06)); }

    .hud { position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: auto 1fr auto; padding: 10px; }
    .hud .top { display: flex; gap: 8px; }
    .chip { pointer-events: auto; user-select: none; padding: 8px 10px; border-radius: 10px; background: rgba(20,30,42,.6); border: 1px solid rgba(40,58,78,.8); backdrop-filter: blur(6px); font-size: 13px; }
    .chip .bar { display: inline-block; width: 110px; height: 8px; border-radius: 6px; background: #0c1420; border: 1px solid #1a2736; overflow: hidden; vertical-align: middle; margin: 0 6px; }
    .chip .bar span { display: block; height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); width: 0%; }

    .centerPrompt { place-self: center; text-align: center; background: rgba(10,15,20,.55); border: 1px solid #1a2736; padding: 16px 18px; border-radius: 16px; backdrop-filter: blur(6px); }
    .centerPrompt h2 { margin: 0 0 8px; letter-spacing: .6px; }
    .centerPrompt p { margin: 0 0 12px; color: var(--muted); }
    .centerPrompt .keys { display: inline-flex; gap: 6px; }

    .tiny { font-size: 12px; color: var(--muted); margin-top: 8px; }

    .credit { position: absolute; bottom: 8px; right: 12px; font-size: 12px; color: #8aa0b8; }
    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div class="shell">
    <!-- Painel lateral -->
    <aside class="panel">
      <h1>Echo<span>Pulse</span></h1>
      <div class="sub">Navegue por labirintos invisíveis usando <strong>ecolocalização</strong>. Emita pulsos para revelar o mundo por alguns segundos. Cuidado com os sentinelas!</div>

      <div class="controls">
        <div class="row" style="margin-bottom:6px"><span class="badge">Como jogar</span></div>
        <p>Movimento: <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> ou setas. Toque/arraste no mobile.</p>
        <p>Ecolocalização: <kbd>ESPAÇO</kbd> ou clique/toque para emitir um <em>pulso</em> da sua posição. Revela paredes/objetos por tempo limitado.</p>
        <p>Objetivo: alcance o portal <span style="color:var(--accent2)">▲</span> evitando os sentinelas <span style="color:var(--danger)">●</span>.</p>
        <p class="tiny">Dica: os sentinelas são atraídos pelo som dos seus pulsos, mas não conseguem te ver quando você está parado.</p>
      </div>

      <div class="stats">
        <div class="row"><span>Nível</span><strong id="uiLevel">1</strong></div>
        <div class="row"><span>Tempo</span><strong id="uiTime">0.0s</strong></div>
        <div class="row"><span>Pulsos usados</span><strong id="uiPulses">0</strong></div>
        <div class="row"><span>Melhor</span><strong id="uiBest">—</strong></div>
      </div>

      <div class="toggles">
        <div class="row" style="margin-bottom:8px">
          <label><input id="reduceMotion" type="checkbox"> Reduzir animações</label>
          <span></span>
        </div>
        <div class="row">
          <label><input id="toggleSound" type="checkbox"> Som do pulso</label>
          <span></span>
        </div>
      </div>

      <button class="primary" id="btnRestart">Reiniciar nível</button>
      <div class="tiny">Gera um novo layout mantendo o nível atual.</div>

      <div class="credit">Feito com ♥ em HTML5 Canvas</div>
    </aside>

    <!-- Área do jogo -->
    <main style="position: relative;">
      <canvas id="game"></canvas>
      <div class="hud">
        <div class="top">
          <div class="chip">Pulsos <div class="bar"><span id="barPulse"></span></div><span id="txtPulse">0%</span></div>
          <div class="chip">Visibilidade <div class="bar"><span id="barFade"></span></div><span id="txtFade">0%</span></div>
          <div class="chip" id="chipMsg" style="display:none"></div>
        </div>
        <div class="centerPrompt" id="startPrompt">
          <h2>↯ Emita um pulso para revelar o mundo</h2>
          <p>Encontre o portal evitando os sentinelas. Eles são atraídos pelo som!</p>
          <div class="keys"><kbd>WASD</kbd> <kbd>←↑→↓</kbd> <kbd>ESPAÇO</kbd></div>
        </div>
        <div style="height: 0"></div>
      </div>
    </main>
  </div>

  <audio id="pingSfx" preload="auto">
    <source src="data:audio/wav;base64,UklGRpADAABXQVZFZm10IBIAAAABAAEAESsAACJWAAACABYAZGF0YRACAACAgICWlpaYmJiDg4OSkpKRkZGAgICGhoabm5u6enp+vr6////9/f3+fn5+Pj4+fn5+vr6+Pj4+fn5+Pj4+Pj4+Pj4+Pj4+fn5+Pj4+Pj4+Pj4+Pj4+Pj4+fn5+Pj4+Pj4+Pj4+Pj4+Pj4" type="audio/wav">
  </audio>

  <script>
  // ==========================
  // EchoPulse — HTML5 Canvas (Modificado)
  // Mecânica: paredes invisíveis, visíveis apenas sob "onda de eco" que decai com o tempo.
  // NOVO: Sentinelas que são atraídos pelo som dos pulsos
  // NOVO: Pulsos são emitidos da posição do jogador
  // ==========================
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const uiLevel = document.getElementById('uiLevel');
    const uiTime = document.getElementById('uiTime');
    const uiPulses = document.getElementById('uiPulses');
    const uiBest = document.getElementById('uiBest');
    const startPrompt = document.getElementById('startPrompt');
    const barPulse = document.getElementById('barPulse');
    const barFade = document.getElementById('barFade');
    const txtPulse = document.getElementById('txtPulse');
    const txtFade = document.getElementById('txtFade');
    const chipMsg = document.getElementById('chipMsg');
    const reduceMotion = document.getElementById('reduceMotion');
    const toggleSound = document.getElementById('toggleSound');
    const pingSfx = document.getElementById('pingSfx');
    const btnRestart = document.getElementById('btnRestart');

    // Ajuste de canvas responsivo
    function fitCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      // preservar aspecto 16:10 aproximado
      canvas.width = Math.floor(rect.width * devicePixelRatio);
      canvas.height = Math.floor(rect.height * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener('resize', fitCanvas);

    // RNG simples
    let seed = Math.floor(Math.random()*1e9);
    function rand() { seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5; return (seed>>>0)/4294967296; }

    // Geração de labirinto (backtracker em grade)
    const GRID = { cols: 31, rows: 19, cell: 28, wall: 6 };
    function generateMaze(cols, rows) {
      const W = cols|0, H = rows|0;
      const grid = Array.from({length: H}, () => Array(W).fill(1)); // 1=parede, 0=chão
      const stack = [];
      const inb = (x,y)=>x>0&&y>0&&x<W-1&&y<H-1;
      function carve(x,y){ grid[y][x]=0; stack.push([x,y]); }
      carve(1,1);
      while(stack.length){
        const [x,y] = stack[stack.length-1];
        const dirs = [[2,0],[-2,0],[0,2],[0,-2]].filter(([dx,dy])=> inb(x+dx,y+dy) && grid[y+dy][x+dx]===1);
        if(dirs.length){
          const [dx,dy] = dirs[(rand()*dirs.length)|0];
          grid[y+dy/2][x+dx/2]=0; grid[y+dy][x+dx]=0; stack.push([x+dx,y+dy]);
        } else stack.pop();
      }
      // abrir algumas salas
      for(let i=0;i<Math.floor(W*H*0.04);i++){
        const x=(rand()*W)|0, y=(rand()*H)|0; grid[y][x]=0;
      }
      return grid;
    }

    // Estado do jogo
    let level=1, pulsesUsed=0, tStart=0, elapsed=0, running=false;
    let grid, start, goal, player, visRings=[];
    let pulseEnergy=1, pulseCooldown=0; // 0..1
    let sentinels = []; // NOVO: Array de sentinelas
    let gameOver = false; // NOVO: Estado de game over

    const bestKey = 'echopulse_best_v1';
    const best = JSON.parse(localStorage.getItem(bestKey)||'{}');

    function resetLevel(newLayout=true){
      if(newLayout){ 
        grid = generateMaze(GRID.cols, GRID.rows); 
        placeStartGoal(); 
        placeSentinels(); // NOVO: Posicionar sentinelas
      }
      player = {...start};
      pulsesUsed=0; elapsed=0; tStart=performance.now(); running=false; visRings.length=0;
      pulseEnergy=1; pulseCooldown=0; startPrompt.style.display='block';
      gameOver = false; // NOVO: Reset game over
      uiLevel.textContent = level; uiPulses.textContent = pulsesUsed; uiTime.textContent = '0.0s';
      showMsg('Novo layout pronto');
      fitCanvas(); draw();
    }

    function placeStartGoal(){
      const freeCells=[]; for(let y=0;y<grid.length;y++) for(let x=0;x<grid[0].length;x++) if(grid[y][x]===0) freeCells.push([x,y]);
      start = toWorld(...freeCells[0]); // canto superior
      goal = toWorld(...freeCells[freeCells.length-1]); // canto oposto
    }

    // NOVO: Função para posicionar sentinelas
    function placeSentinels(){
      sentinels = [];
      const freeCells=[]; 
      for(let y=0;y<grid.length;y++) {
        for(let x=0;x<grid[0].length;x++) {
          if(grid[y][x]===0) freeCells.push([x,y]);
        }
      }
      
      // Número de sentinelas baseado no nível (mínimo 2, máximo 5)
      const numSentinels = Math.min(5, Math.max(2, Math.floor(level / 2) + 1));
      
      for(let i = 0; i < numSentinels; i++){
        if(freeCells.length > 2) { // Garantir que há células livres
          const randomIndex = Math.floor(rand() * freeCells.length);
          const [cx, cy] = freeCells[randomIndex];
          const worldPos = toWorld(cx, cy);
          
          // Evitar colocar sentinelas muito perto do início ou fim
          const distFromStart = Math.hypot(worldPos.x - start.x, worldPos.y - start.y);
          const distFromGoal = Math.hypot(worldPos.x - goal.x, worldPos.y - goal.y);
          
          if(distFromStart > GRID.cell * 3 && distFromGoal > GRID.cell * 2) {
            sentinels.push({
              x: worldPos.x,
              y: worldPos.y,
              targetX: worldPos.x,
              targetY: worldPos.y,
              speed: 80 + rand() * 40, // Velocidade variável
              alertTime: 0 // Tempo desde o último pulso ouvido
            });
            freeCells.splice(randomIndex, 1); // Remove a célula usada
          }
        }
      }
    }

    function toWorld(cx,cy){ return { x: (cx+0.5)*GRID.cell + 40, y: (cy+0.5)*GRID.cell + 40 } }
    function toCell(px,py){ return { cx: Math.floor((px-40)/GRID.cell), cy: Math.floor((py-40)/GRID.cell) } }

    // Colisão simples AABB com paredes
    function isWallAt(px,py){
      const {cx,cy} = toCell(px,py);
      if(cy<0||cx<0||cy>=grid.length||cx>=grid[0].length) return true;
      return grid[cy][cx]===1;
    }

    const keys = new Set();
    window.addEventListener('keydown', e=>{
      keys.add(e.key.toLowerCase()); 
      if(['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase())) e.preventDefault(); 
      if(e.key === ' ') { // NOVO: Espaço para emitir pulso
        echoPulse();
      }
      running=true; 
      startPrompt.style.display='none'; 
    });
    window.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));

    // Controles de toque/arraste
    let pointer = null;
    canvas.addEventListener('pointerdown', e=>{ 
      pointer={id:e.pointerId,x:e.offsetX,y:e.offsetY,drag:false}; 
      running=true; 
      startPrompt.style.display='none'; 
      echoPulse(); // NOVO: Pulso da posição do jogador
    });
    canvas.addEventListener('pointermove', e=>{ if(pointer && e.pointerId===pointer.id){ pointer.drag=true; pointer.x=e.offsetX; pointer.y=e.offsetY; }});
    window.addEventListener('pointerup', e=>{ if(pointer && e.pointerId===pointer.id) pointer=null; });
    canvas.addEventListener('click', e=>{ echoPulse(); }); // NOVO: Pulso da posição do jogador

    btnRestart.addEventListener('click', ()=> resetLevel(true));

    toggleSound.addEventListener('change', ()=>{});

    // NOVO: Função modificada para emitir pulso da posição do jogador
    function echoPulse(){
      if(pulseEnergy < 0.2) { showMsg('Sem energia… aguarde recarga'); return; }
      if(gameOver) return; // Não permitir pulsos durante game over
      
      pulsesUsed++; uiPulses.textContent = pulsesUsed;
      // NOVO: Pulso emitido da posição do jogador
      visRings.push({ x: player.x, y: player.y, r: 0, strength: 1 });
      pulseEnergy = Math.max(0, pulseEnergy - 0.34);
      pulseCooldown = 1;
      
      // NOVO: Alertar sentinelas sobre o pulso
      alertSentinels(player.x, player.y);
      
      if(toggleSound.checked){ try{ pingSfx.currentTime=0; pingSfx.play(); }catch(_){} }
    }

    // NOVO: Função para alertar sentinelas sobre o som
    function alertSentinels(soundX, soundY){
      sentinels.forEach(sentinel => {
        const distance = Math.hypot(sentinel.x - soundX, sentinel.y - soundY);
        // Sentinelas ouvem o som em um raio de 200 pixels
        if(distance < 200) {
          sentinel.targetX = soundX;
          sentinel.targetY = soundY;
          sentinel.alertTime = 3; // Ficam alertas por 3 segundos
        }
      });
    }

    function showMsg(text){
      chipMsg.textContent = text; chipMsg.style.display='block';
      clearTimeout(showMsg._t);
      showMsg._t = setTimeout(()=> chipMsg.style.display='none', 1400);
    }

    // Loop
    let last=performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000); last = now;
      if(running && !gameOver) elapsed = (now - tStart)/1000;

      // Recarregar energia e decaimento do efeito de visibilidade
      pulseEnergy = Math.min(1, pulseEnergy + dt*0.22);
      if(pulseCooldown>0) pulseCooldown = Math.max(0, pulseCooldown - dt*0.5);

      update(dt);
      draw();
      requestAnimationFrame(tick);
    }

    function update(dt){
      if(gameOver) return; // Não atualizar durante game over

      // movimento do jogador
      const speed = 160 * (reduceMotion.checked ? 1.1 : 1);
      let vx=0, vy=0;
      if(keys.has('w')||keys.has('arrowup')) vy -= 1;
      if(keys.has('s')||keys.has('arrowdown')) vy += 1;
      if(keys.has('a')||keys.has('arrowleft')) vx -= 1;
      if(keys.has('d')||keys.has('arrowright')) vx += 1;
      if(pointer && pointer.drag){ // arraste direciona
        const dx = pointer.x - player.x; const dy = pointer.y - player.y; const m = Math.hypot(dx,dy)||1; vx = dx/m; vy = dy/m;
      }
      const mag = Math.hypot(vx,vy)||1; vx/=mag; vy/=mag;
      const step = speed*dt;
      // tentativa eixo X
      if(!isWallAt(player.x + vx*step, player.y)) player.x += vx*step; else if(vx) pulseHint();
      // eixo Y
      if(!isWallAt(player.x, player.y + vy*step)) player.y += vy*step; else if(vy) pulseHint();

      // NOVO: Atualizar sentinelas
      updateSentinels(dt);

      // NOVO: Verificar colisão com sentinelas
      checkSentinelCollision();

      // Atualiza anéis de eco
      for(const ring of visRings){
        ring.r += (reduceMotion.checked? 220: 320)*dt; // raio cresce
        ring.strength -= dt * 0.28; // decaimento
      }
      visRings = visRings.filter(r=> r.strength>0);

      // UI barras
      barPulse.style.width = (pulseEnergy*100).toFixed(0)+'%';
      txtPulse.textContent = (pulseEnergy*100).toFixed(0)+'%';
      const fadeAvg = visRings.reduce((a,b)=>a+b.strength,0)/Math.max(1,visRings.length);
      barFade.style.width = (Math.min(1, fadeAvg)*100).toFixed(0)+'%';
      txtFade.textContent = (Math.min(1, fadeAvg)*100).toFixed(0)+'%';

      // vitória
      if(Math.hypot(player.x-goal.x, player.y-goal.y) < GRID.cell*0.4){
        onWin();
      }

      uiTime.textContent = elapsed.toFixed(1)+'s';
    }

    // NOVO: Função para atualizar sentinelas
    function updateSentinels(dt){
      sentinels.forEach(sentinel => {
        // Reduzir tempo de alerta
        if(sentinel.alertTime > 0) {
          sentinel.alertTime -= dt;
        }

        // Se estão alertas, mover em direção ao som
        if(sentinel.alertTime > 0) {
          const dx = sentinel.targetX - sentinel.x;
          const dy = sentinel.targetY - sentinel.y;
          const distance = Math.hypot(dx, dy);
          
          if(distance > 5) { // Se não chegou ao destino
            const moveX = (dx / distance) * sentinel.speed * dt;
            const moveY = (dy / distance) * sentinel.speed * dt;
            
            // Verificar colisão com paredes antes de mover
            if(!isWallAt(sentinel.x + moveX, sentinel.y)) {
              sentinel.x += moveX;
            }
            if(!isWallAt(sentinel.x, sentinel.y + moveY)) {
              sentinel.y += moveY;
            }
          }
        }
      });
    }

    // NOVO: Função para verificar colisão com sentinelas
    function checkSentinelCollision(){
      sentinels.forEach(sentinel => {
        const distance = Math.hypot(player.x - sentinel.x, player.y - sentinel.y);
        if(distance < GRID.cell * 0.6) { // Colisão detectada
          gameOver = true;
          showMsg('Detectado pelos sentinelas!');
          setTimeout(() => {
            resetLevel(false); // Reiniciar sem gerar novo layout
          }, 1500);
        }
      });
    }

    function pulseHint(){
      if(pulseCooldown===0) showMsg('Emita um pulso para ver!');
    }

    function onWin(){
      const key = 'L'+level;
      const score = { t: +elapsed.toFixed(2), p: pulsesUsed };
      if(!best[key] || score.t < best[key].t || (score.t===best[key].t && score.p < best[key].p)) best[key]=score;
      localStorage.setItem(bestKey, JSON.stringify(best));
      uiBest.textContent = best[key]? `${best[key].t}s / ${best[key].p}p` : '—';

      level++;
      uiLevel.textContent = level;
      showWinPrompt();
      // novo layout para o próximo nível
      grid = generateMaze(GRID.cols + (level%2?0:2), GRID.rows + (level%2?0:2));
      placeStartGoal();
      placeSentinels(); // NOVO: Posicionar sentinelas no novo nível
      player = {...start};
      pulsesUsed=0; elapsed=0; tStart=performance.now(); visRings.length=0; running=false; startPrompt.style.display='block';
      gameOver = false; // NOVO: Reset game over
    }

    function showWinPrompt(){
      const el = document.createElement('div');
      el.className = 'centerPrompt';
      el.innerHTML = `<h2>🎯 Nível ${level-1} completo!</h2><p>Tempo: ${elapsed.toFixed(1)}s • Pulsos: ${pulsesUsed}</p>`;
      el.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:999;animation:fadeIn .3s ease';
      document.body.appendChild(el);
      setTimeout(()=> el.remove(), 2200);
    }

    function draw(){
      const w = canvas.width/devicePixelRatio, h = canvas.height/devicePixelRatio;
      ctx.clearRect(0,0,w,h);

      // Fundo escuro
      ctx.fillStyle = '#05070a'; ctx.fillRect(0,0,w,h);

      // Desenhar paredes (apenas as visíveis pelos anéis de eco)
      ctx.fillStyle = '#1a2736';
      for(let y=0; y<grid.length; y++){
        for(let x=0; x<grid[0].length; x++){
          if(grid[y][x]===1){ // é parede
            const wx = x*GRID.cell + 40, wy = y*GRID.cell + 40;
            let visible = false;
            for(const ring of visRings){
              const dist = Math.hypot(wx+GRID.cell/2-ring.x, wy+GRID.cell/2-ring.y);
              if(dist <= ring.r && ring.strength > 0.1){
                visible = true; break;
              }
            }
            if(visible){
              ctx.globalAlpha = Math.min(1, visRings.reduce((a,r)=> Math.max(a, r.strength*0.8), 0));
              ctx.fillRect(wx, wy, GRID.cell, GRID.cell);
            }
          }
        }
      }
      ctx.globalAlpha = 1;

      // NOVO: Desenhar sentinelas (apenas os visíveis pelos anéis de eco)
      sentinels.forEach(sentinel => {
        let visible = false;
        let maxStrength = 0;
        for(const ring of visRings){
          const dist = Math.hypot(sentinel.x - ring.x, sentinel.y - ring.y);
          if(dist <= ring.r && ring.strength > 0.1){
            visible = true;
            maxStrength = Math.max(maxStrength, ring.strength);
          }
        }
        if(visible){
          ctx.globalAlpha = Math.min(1, maxStrength * 0.9);
          ctx.fillStyle = sentinel.alertTime > 0 ? '#ff6b6b' : '#ff9999'; // Vermelho mais intenso quando alerta
          ctx.beginPath();
          ctx.arc(sentinel.x, sentinel.y, GRID.cell * 0.3, 0, Math.PI * 2);
          ctx.fill();
          
          // Indicador de direção quando alerta
          if(sentinel.alertTime > 0) {
            const dx = sentinel.targetX - sentinel.x;
            const dy = sentinel.targetY - sentinel.y;
            const distance = Math.hypot(dx, dy);
            if(distance > 5) {
              ctx.strokeStyle = '#ff6b6b';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(sentinel.x, sentinel.y);
              ctx.lineTo(sentinel.x + (dx/distance) * 15, sentinel.y + (dy/distance) * 15);
              ctx.stroke();
            }
          }
        }
      });
      ctx.globalAlpha = 1;

      // Desenhar anéis de eco
      for(const ring of visRings){
        if(ring.strength <= 0) continue;
        ctx.strokeStyle = `rgba(122,224,255,${ring.strength*0.6})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(ring.x, ring.y, ring.r, 0, Math.PI*2);
        ctx.stroke();
        
        // Anel interno mais fraco
        ctx.strokeStyle = `rgba(140,255,181,${ring.strength*0.3})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(ring.x, ring.y, ring.r*0.7, 0, Math.PI*2);
        ctx.stroke();
      }

      // Portal (objetivo)
      ctx.fillStyle = '#8cffb5';
      ctx.beginPath();
      ctx.moveTo(goal.x, goal.y-12);
      ctx.lineTo(goal.x-10, goal.y+8);
      ctx.lineTo(goal.x+10, goal.y+8);
      ctx.closePath();
      ctx.fill();

      // Jogador
      ctx.fillStyle = gameOver ? '#ff6b6b' : '#7ae0ff'; // NOVO: Vermelho quando game over
      ctx.beginPath();
      ctx.arc(player.x, player.y, 8, 0, Math.PI*2);
      ctx.fill();
    }

    // Inicialização
    resetLevel();
    tick(performance.now());
  })();
  </script>
</body>
</html>
